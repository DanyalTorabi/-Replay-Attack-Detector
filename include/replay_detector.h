#ifndef REPLAYDETECTOR_H
#define REPLAYDETECTOR_H
#include <unordered_map>
#include <map>
#include <set>

//! Determines a number of shifts for detecting block number from packet number and vice versa. This
//! value is relevant to the number of bits in each block.
#define REPLAY_DETECTOR_SHIFT 6ULL
//! Determines a mask for detecting position of a packet's sign in a block. This value is relevant
//! to the number of bits in each block.
#define REPLAY_DETECTOR_MASK 0x3FULL
//! Determines number of bits(packets) on each block.
#define REPLAY_DETECTOR_BLOCK_BIT_COUNT 64ULL
// #define REPLAY_DETECTOR_DEBUG
//! ReplayDetector class

/*! This is a class that detects duplicated packets generated by `Man In The Middle` attackers in
   order to increase the load of receiver.
   The main responsibility of the class is to determine state of received packets in a low latency
      process and return an output in one of these cases:
      1- Received packet should be saved.
      2- Received packet is already received and it's not a valid packet.
      3- Received packet is too old (out of window) and class is unable to detect the correct state
         of packet.
      4- Received packet is too old and the greatest received packet number is by far more than 2
         power 63. So, the overflow phenomenon might be happened.
   The class has a window in which it accepts packets. The window conists of 64-bit blocks each of
      whose bits shows the receive state of one packet.
   The window move forward by removing the first block and adding empty block at the end of window
                        when first block is filled(In other word, when 64 packets of a first block
                           are recieved.) It
      also move forward whether a packet whose number is greater than the last packet number in the
      window was received. In this case, more missed packet numbers are reported.
   ReplayDetector class needs to know the size of window in block unit, first packet and block number
      in the window to work. Moreover, `window block count` is rounded up, because it is made of
                        `window packet count`, however, it finally increases one block. For example,
                           if the `window
      packet count` sets to 1000, real size of window is 1088 packets.
   It is recommended to use this class in the range of 1 to (2^64 - 2*WindowSize), however it works
      until (2^64-2)
   \warning This is not a thread safe class.
 */

class ReplayDetector
{
public:
	//!
	//! \brief The ResultTypes enum
	//!

	/*! This is the result types of evaluating a packet number by which you can find out what happened
               in the sequence of packets. */
	enum ResultTypes
	{
		//! The state of being duplicate or correct is undefined because the packet number is by far
		//! less than first packet in our window.
		RT_Unknown,
		//! Packet is correct and should be saved.
		RT_Save,
		//! Packet was received before and it's a duplicated packet.
		RT_Duplicate,
		//! Packet number might be go over 2 power 64.
		RT_Overflow,
	};

public:
	///
        /// \brief ReplayDetector Constructor of class.
	/// \param windowPacketSize determines the of window size in transportation layer.
	/// \note windowPacketSize will be a factor of 64 later. It also increases by 64 for some reasons.
	/// For example if this parameter is set to 1000 it becomes 1088.
	/// \param startPacketNumber determines the first packet number expected to be received.
	///
        explicit ReplayDetector(uint64_t windowPacketSize, uint64_t startPacketNumber);

	///
        /// \brief ~ReplayDetector Destructor of class.
	///
    virtual ~ReplayDetector()
    { }

	///
	/// \brief checkPacketNumber checks a newly received packet number.
	/// \param packetNumber is the number assigned to the received packet.
	/// \return Return value is one of `ReturnType` enumeration by which you can realized how you
	/// should react aginst received packet.
	///
	ResultTypes  checkPacketNumber(uint64_t packetNumber);

	///
	/// \brief startPacketNumber is the first packet number in the window.
	/// It is a one-based number. It is practical for making test cases.
	/// \return First packet number in the window is returned.
	///
	uint64_t  startPacketNumber() const;

	///
	/// \brief startBlockNumber is the first number block in the window.
	/// It is a one-based number. It is practical for making test cases.
	/// \return First block number in the window is returned.
	///
	uint64_t  startBlockNumber() const;

	///
	/// \brief acceptedPacketCount is the number of packets which are correct.
	/// \return Number of packets which are correct is returned.
	///
	uint64_t  acceptedPacketCount() const;

	///
	/// \brief missedPacketCount is the number of not received packets which were in the range of
	/// window.
	/// \return Number of missed packet is returned.
	///
	uint64_t  missedPacketCount() const;

	///
	/// \brief unfilledPacketCount is the number of not received packets in the range of window.
	/// \return Number of not received packets in the range of window is returned.
	///
	uint64_t  unfilledPacketCount() const;

	///
	/// \brief duplicatedPacketCount is the number of duplicated packets.
	/// \return Number of dupllicated packets is returned.
	///
	uint64_t  duplicatedPacketCount() const;

private:
	//! Bitwise blocks used to store state of receiving. The key is block number.
	std::unordered_map<uint64_t, uint64_t>  _blocks;
	//! Maximum number of blocks.
	uint64_t  _windowBlockCount;
	//! First packet number in our buffer.
	uint64_t  _startPacketNumber;
	//! Zero-based number of first block in the map.
	uint64_t  _startBlockNumber;
	/// Zero-based number of last block in the map.
	uint64_t  _lastBlockNumber;
	//! Number of packets which are returned as `Save`.
	uint64_t  _acceptedPacketCount;
	//! Number of packets which are missed when window moves forward.
	uint64_t  _missedPacketCount;
	//! Number of not received packets in the range of window.
	uint64_t  _unfilledPacketCount;
	//! Number of duplicated packets.
	uint64_t  _duplicatedPacketCount;
	//! Number of duplicated packets.
	uint64_t  _maximumReceivedPacketNumber;
	//!
	//! \brief checkBlocks It checks the blocks in order to moving the `StartPacketNumber` and
	//! `StartBlockNumber` forward.

	/*! \details In this function all the blocks whose bits are set and located in the start of window
               are released. It causes the window moves forward. It also measures the distance between
                  first
               and last block in order to move the window forward.
	 */
    inline void  checkBlocks();

    //!
    //! \brief removeExceptionalFirstBlock It removes the first block in the window whether all
    //! packets of first block are received and the first
    //! block is not a complete block. The incomplete block is created in the strartup if the first
    //! packet number is not multiple of 64.
    //! \param it reference to the first block according to the first packet number. It might be out
    //! of range of iterator.
    //!
    void  removeExceptionalFirstBlock(const std::unordered_map<uint64_t,
                                                               uint64_t>::iterator &it);

    //!
    //! \brief removeFirstBlock It checks the first block and remove it from the window whther all of
    //! its packets are received.
    //! \param it reference to the first block according to the first packet number. It might be out
    //! of range of iterator.
    //!
    void  removeFirstBlock(std::unordered_map<uint64_t, uint64_t>::iterator  &it);

    //!
    //! \brief moveWindowForward It check the distance of first and last packets and move the window
    //! forward if the current distance is out of the defined size of window.
    //! In this case some first packet number might be reported as missed packets.
    //! \param currentWindowBlockCount It determines the currant window size of blocks made by
    //! difference between first and last pacekt number.
    //!
    void  moveWindowForward(const uint64_t &currentWindowBlockCount);
};

#endif // REPLAYDETECTOR_H
